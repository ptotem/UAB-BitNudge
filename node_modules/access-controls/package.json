{
  "name": "access-controls",
  "version": "0.4.0",
  "description": "rule based access-controls engine for node.js (browser compatible)",
  "main": "index.js",
  "scripts": {
    "prepublish": "make test",
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/nherment/node-access-controls.git"
  },
  "keywords": [
    "access",
    "control",
    "rules",
    "permissions"
  ],
  "author": {
    "name": "Nicolas Herment",
    "email": "nherment@gmail.com"
  },
  "license": "Public Domain",
  "bugs": {
    "url": "https://github.com/nherment/node-access-controls/issues"
  },
  "homepage": "https://github.com/nherment/node-access-controls",
  "dependencies": {
    "lodash": "2.4.1",
    "object-tree": "0.2.5",
    "patrun": "0.2.0"
  },
  "devDependencies": {
    "chai": "1.9.1",
    "browserify": "4.1.8",
    "mocha": "1.20.1",
    "node-phantom": "0.2.5",
    "mocha-phantomjs": "3.4.1",
    "phantomjs": "1.9.7-8"
  },
  "readme": "[![Build Status](https://api.travis-ci.org/nherment/node-access-controls.png?branch=master)](https://travis-ci.org/nherment/node-access-controls)\n\n\n# install\n\n### node.js\n\n    npm install --save access-controls\n\n### browser\n\nUse the file in dist/access-controls.js\n\n    <script src=\"access-controls.js\"></script>\n\n\n    var procedure = new AccessControls(accessControlList)\n\n    procedure.authorize(obj, action, roles, context, function(err, authDecision) {\n      // authDecision attributes\n      // authorize: true | false\n      // history: a list of the ACLs run\n      // inherit: if there is an inheritance condition to access this entity\n      // filters: an array of filters if some fields need filtering.\n      //          You can use procedure.applyFilters(authDecision.filters, obj) to\n      //          apply them\n    })\n\n\n# Usage\n\n    var accessControlList = [{\n      name: 'EMEA_region',\n      roles: ['EMEA'],\n      control: 'required',\n      actions: 'r',\n      conditions: [{\n          attributes: {\n            'region': 'EMEA'\n          }\n        }\n      ]\n    }, {\n      name: 'legal_group',\n      roles: ['legal'],\n      control: 'required',\n      actions: ['load'],\n      conditions: [{\n          attributes: {\n            'group': 'legal'\n          }\n        }\n      ]\n    }, {\n      name: 'admin all access',\n      roles: ['admin'],\n      control: 'sufficient',\n      actions: ['load', 'list', 'save', 'remove']\n    }]\n\n    var procedure = new AccessControlProcedure(accessControlList)\n\n    proc = procedure.authorize(obj, context, action)\n\n    proc.on('deny', function(details) {\n\n    })\n\n    proc.on('grant', function(details) {\n\n    })\n\n    proc.on('dependency', function(details) {\n\n    })\n\n\n## Access Controls\n\nAn access control procedure runs a set of ACLs against a given pair of ```entity``` and ```action```\n\nAn ACL is composed of:\n\n- a list of roles which are required for this ACL to authorize\n- a set of actions (save, update, get, list)\n- on a given entity (the type as well as specific attributes values)\n- a control type (one of required|requisite|sufficient) that determine what happens should the ACL fail or succeed:\n  - ```required``` — The service result must be successful for authentication to continue. If the test fails at this point, the user is not notified until the results of all service tests that reference that interface are complete.\n  - ```requisite``` — The service result must be successful for authentication to continue. However, if a test fails at this point, the user is notified immediately with a message reflecting the first failed required or requisite service test.\n  - ```sufficient``` — The service result is ignored if it fails. However, if the result of a service flagged sufficient is successful and no previous services flagged required have failed, then no other results are required and the user is authenticated to the service.\n\n> IMPORTANT: The order in which ```required``` ACLs are called is not critical. Only the ```sufficient``` and ```requisite``` control flags cause order to become important.\n\nExamples:\n```\n    si.use( '..', {\n      accessControls: [{\n        name: 'access to foobar entities',\n        roles: ['foobar'],\n        entities: [{\n          zone: undefined,\n          base: undefined,\n          name: 'foobar'\n        }],\n        control: 'required',\n        actions: ['save', 'load', 'list', 'remove'],\n        conditions: []\n      },{\n        name: 'access to foobar EMEA entities',\n        roles: ['EMEA'],\n        entities: [{\n          zone: undefined,\n          base: undefined,\n          name: 'foobar'\n        }],\n        control: 'required',\n        actions: ['save', 'load', 'list', 'remove'],\n        conditions: [{\n            attributes: {\n              'region': 'EMEA'\n            }\n          }\n        ]\n      },{\n        name: 'access to foobar EMEA entities',\n        roles: ['private_items'],\n        entities: [{\n          zone: undefined,\n          base: undefined,\n          name: 'item'\n        }],\n        control: 'required',\n        actions: ['load'],\n        conditions: [{\n            attributes: {\n              'status': 'private'\n            }\n          }\n        ]\n      }]\n    })\n```\n\n### Field level access/masking\n\nField masking works a bit differently compared to other ACLs.\n\nIt is possible to mask or deny access to specific fields IF the access roles are not met.\n\nFor example:\n\n    si.use( '..', {\n      accessControls: [{\n        name: 'access to foobar entities',\n        roles: ['foobar', 'ssn'],\n        entities: [{\n          zone: undefined,\n          base: undefined,\n          name: 'foobar'\n        }],\n        control: 'filter',\n        actions: ['load'],\n        conditions: [{\n            attributes: {\n              'status': 'private'\n            }\n          }\n        ],\n        filters: {\n          lastName: false,\n          ssn: function(value) {\n            if(value) {\n              value = '***-***-' + value.substr(-4)\n            }\n          }\n        }\n      }]\n    })\n\nWill:\n\n- mask the field ```ssn``` and only display the last 4 digits\n- completely hide the field ```lastName```\n\nfor all access except those with roles ```foobar``` and ```ssn```.\n\n### manual validation\n\nYou can manually invoke the ACLs by setting the ```perm$``` attribute in the arguments:\n\n      var publicAccess = si.delegate({perm$:{roles:[]}})\n      var pf1 = publicAccess.make('item',{number: 1, status: 'public'})\n\n      var privateAccess = si.delegate({perm$:{roles:['private_items']}})\n      var pf2 = privateAccess.make('item',{number: 2, status: 'private'})\n\n### current context\n\nIn some cases, you want to run access controls against the current logged in user.\nFor this, you can reference the current user in an ACL:\n\n\n    si.use( '..', {\n      accessControls: [{\n        name: 'todos: owner only',\n        roles: ['my_todos'],\n        entities: [{\n          zone: undefined,\n          base: undefined,\n          name: 'todo'\n        }],\n        control: 'required',\n        actions: ['save', 'load', 'list', 'remove'],\n        conditions: [{\n            attributes: {\n              'owner': '{user.id}'\n            }\n          }\n        ]\n      }]\n    })\n\nThe above will allow users to only create, read, update or delete 'todo' objects where they are the owner.\n",
  "readmeFilename": "README.md",
  "_id": "access-controls@0.4.0",
  "dist": {
    "shasum": "f543420751d1a621991ab031cbd44e690a22b75f"
  },
  "_from": "access-controls@",
  "_resolved": "https://registry.npmjs.org/access-controls/-/access-controls-0.4.0.tgz"
}
